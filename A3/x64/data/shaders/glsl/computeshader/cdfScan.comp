#version 450

#define HISTOGRAM256BINCOUNT 256

#define mymin( a , b ) ((( a ) < ( b )) ? ( a ) : ( b ) )
#define mymax( a , b ) ((( a ) > ( b )) ? ( a ) : ( b ) )

//change to function
#define PROB(x ,width, height) (x) / ((width) * (height))
#define CLAMP(x, start, end) (mymin(mymax((x),(start)),(end)))


layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform readonly image2D inputImage;
layout (binding = 1, rgba8) uniform image2D resultImage;

struct bufferHistoeq
{
	uint histoBin[256];
	float cdf[256];
};

layout (binding = 2) buffer StorageBuffer
{
	bufferHistoeq buf;
} storageBuffer;

shared float scan[2 * HISTOGRAM256BINCOUNT]; // declare shared memory


void main()
{	

	// CDF scan - calculate cdf for histogram bias
    // vec4 pixel_color = imageLoad(inputImage, ivec2(gl_GlobalInvocationID.xy));
	
    // ivec2 size = imageSize(inputImage); // gets the image2d size

	// storageBuffer.buf.cdf[0] = PROB(float(storageBuffer.buf.histoBin[0]) , size.x, size.y);

	// // PROB((float)storageBuffer.buf.histo[0], size.x, size.y );
	// // vec4 res = vec4(pixel_color.r * storageBuffer.buf.cdf[0], pixel_color.g,pixel_color.b  , pixel_color.w);

	// ivec2 xy_int = ivec2(gl_GlobalInvocationID.xy); // x and y of current pixel in the image
	// int i = (xy_int.y * size.x) + xy_int.x; 	// calcualte the index
	// if( i < HISTOGRAM256BINCOUNT )
	// {
	// 	float pdf = PROB(float(storageBuffer.buf.histoBin[i]) , size.x, size.y);
	// 	storageBuffer.buf.cdf[i] = pdf + storageBuffer.buf.histoBin[i - 1];
	// }


	// imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), res);
	// imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), pixel_color);



}
