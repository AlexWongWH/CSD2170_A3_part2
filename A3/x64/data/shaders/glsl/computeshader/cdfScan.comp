#version 450

#define HISTOGRAM256BINCOUNT 256

// #define mymin( a , b ) ((( a ) < ( b )) ? ( a ) : ( b ) )
// #define mymax( a , b ) ((( a ) > ( b )) ? ( a ) : ( b ) )
// #define CLAMP(x, start, end) (mymin(mymax((x),(start)),(end)))

//change to function?
#define PROB(x ,width, height) (x) / ((width) * (height))


layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform readonly image2D inputImage;
layout (binding = 1, rgba8) uniform image2D resultImage;

struct bufferHistoeq
{
	uint histoBin[256];
	float cdf[256];
};

layout (binding = 2) buffer StorageBuffer
{
	bufferHistoeq buf;
} storageBuffer;

shared float scan[2 * HISTOGRAM256BINCOUNT]; // declare shared memory


void main()
{	

	// CDF scan - calculate cdf for histogram bias
    vec4 pixel_color = imageLoad(inputImage, ivec2(gl_GlobalInvocationID.xy));
	
    ivec2 imgSize = imageSize(inputImage); // gets the image2d size

	//histoCDF[ 0 ] = PROB( (float)histo [0] , imgWidth , imgHeight );
	storageBuffer.buf.cdf[0] = PROB(float(storageBuffer.buf.histoBin[0]) , imgSize.x, imgSize.y);

	// PROB((float)storageBuffer.buf.histo[0], size.x, size.y );
	// vec4 res = vec4(pixel_color.r * storageBuffer.buf.cdf[0], pixel_color.g,pixel_color.b  , pixel_color.w);

	// ivec2 xy_int = ivec2(gl_GlobalInvocationID.xy); // x and y of current pixel in the image
	// int i = (xy_int.y * imgSize.x) + xy_int.x; 	// calculate the index
	// if( i < HISTOGRAM256BINCOUNT )
	// {
	// 	float pdf = PROB(float(storageBuffer.buf.histoBin[i]) , imgSize.x, imgSize.y);
	// 	storageBuffer.buf.cdf[i] = pdf + storageBuffer.buf.cdf[i - 1];
	// }

	for( int i = 1 ; i < HISTOGRAM256BINCOUNT; ++i )
	{
		float pdf = PROB(float(storageBuffer.buf.histoBin[i]) , imgSize.x, imgSize.y);
		storageBuffer.buf.cdf[i] = pdf + storageBuffer.buf.cdf[i - 1];
	}



	//debug checking if semaphores are correct
	// float c = storageBuffer.buf.histoBin[0];
	// // imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), res);
	// imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4( c, 0, 0, 1));


}
