#version 450

#define HISTOGRAM256BINCOUNT 256

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform readonly image2D inputImage;
layout (binding = 1, rgba8) uniform image2D resultImage;


struct bufferHistoeq
{
	uint histoBin[256];
	float cdf[256];
};

//shd be set 0 , binding 2
layout (binding = 2) buffer StorageBuffer
{
	bufferHistoeq buf;
} storageBuffer;

//convert the input of RGB model into YUV model 

void main()
{	


	ivec2 xy_int = ivec2(gl_GlobalInvocationID.xy); // x and y of current pixel in the image

	//might have to find better method
	// Pixel color form the image
	vec4 pixel_color = imageLoad(inputImage, xy_int);
	
	// vec4 pixel2 = imageLoad(inputImage, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y + size.x) );

	float y = 0.299f * pixel_color.r + 0.587f * pixel_color.g + 0.114f * pixel_color.b;
	float u = -0.169f * pixel_color.r - 0.331f * pixel_color.g + 0.499f * pixel_color.b + 0.5f;
	float v = 0.499f * pixel_color.r - 0.418f * pixel_color.g - 0.0813f * pixel_color.b + 0.5f;
	
	/*genType clamp( genType x, genType minVal, genType maxVal); */

	float r = clamp(y, 0 , 1); // clamp between 0~255
	float g = clamp(u, 0 , 1); // clamp between 0~255
	float b = clamp(v, 0 , 1); // clamp between 0~255
	// storageBuffer.buf.histoBin[]
	
	// vec4 res = vec4(pixel_color.r, pixel_color.g, pixel_color.b, pixel_color.w);
	vec4 res = vec4(r,g,b,pixel_color.w);
	// imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), res);


    ivec2 size = imageSize(inputImage); // gets the image2d size
    int imgSize = size.x * size.y; 		// img size, not used yet

	//histo[dataYUV[i]]++; // Histogram for Y

	//this condition check might be useless
	// if( gl_GlobalInvocationID.x * gl_GlobalInvocationID.y < imgSize)
	// {}
	// i = (row * width) + col // should not need this
	// atomicAdd(storageBuffer.buf.histoBin[i],1); // this line should be wrong
	

	// memoryBarrier();	
	// barrier();
	//histogram on Y component


	// Shaders are from 0~1
	atomicAdd(storageBuffer.buf.histoBin[uint(y*255)],1); // this line might be wrong
	// int i = (xy_int.y * size.x) + xy_int.x; 	// calcualte the index
	// storageBuffer.buf.histoBin[0] = 100;

	for( uint i = 0 ; i < 256; ++i)
	{
		storageBuffer.buf.histoBin[i] = 1512;
		storageBuffer.buf.cdf[i] = 512;
	}

	barrier();
	// atomicAdd(storageBuffer.buf.histoBin[i],1); // this line might be wrong


}